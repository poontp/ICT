<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Oxford Smart Checker (Context Aware)</title>
    <style>
        :root {
            --primary: #2563eb;
            --bg-page: #f8fafc;
            --bg-card: #ffffff;
            --text-main: #0f172a;
            --text-muted: #64748b;
            --border: #e2e8f0;
            --success: #10b981;
            --success-bg: #d1fae5;
            
            /* Level Colors */
            --level-a-bg: #eff6ff;
            --level-a-text: #1e40af;
            --level-b-bg: #fffbeb;
            --level-b-text: #92400e;
            --level-c-bg: #faf5ff;
            --level-c-text: #6b21a8;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-page);
            color: var(--text-main);
            line-height: 1.5;
            padding: 2rem 1rem;
        }

        .container { max-width: 1200px; margin: 0 auto; }

        /* Header */
        header { text-align: center; margin-bottom: 2.5rem; }
        h1 {
            font-size: 2rem;
            font-weight: 800;
            margin-bottom: 0.5rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.75rem;
            color: #1e293b;
        }
        .smart-badge {
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            color: white;
            font-size: 0.75rem;
            padding: 4px 10px;
            border-radius: 20px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            vertical-align: middle;
        }

        /* Grid Layout */
        .grid {
            display: grid;
            grid-template-columns: 1fr;
            gap: 1.5rem;
            margin-bottom: 2rem;
        }
        @media (min-width: 900px) { .grid { grid-template-columns: 1fr 1fr; } }

        /* Cards */
        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            padding: 1.5rem;
            box-shadow: 0 1px 3px rgba(0,0,0,0.05);
            display: flex;
            flex-direction: column;
            height: 450px;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        .card-label { font-weight: 700; display: flex; align-items: center; gap: 0.5rem; }
        
        /* Inputs */
        textarea {
            flex: 1;
            width: 100%;
            padding: 1rem;
            border: 1px solid var(--border);
            border-radius: 0.5rem;
            resize: none;
            font-family: monospace;
            font-size: 0.95rem;
            line-height: 1.6;
        }
        textarea:focus { outline: none; border-color: var(--primary); ring: 2px solid var(--primary); }

        /* Upload Area */
        .upload-area {
            flex: 1;
            border: 2px dashed var(--border);
            border-radius: 0.5rem;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
            background: #f8fafc;
            text-align: center;
            padding: 1rem;
        }
        .upload-area:hover { border-color: var(--primary); background: #eff6ff; }
        .upload-area.has-file { border-color: var(--success); background: #f0fdf4; }
        
        .icon-large { width: 48px; height: 48px; margin-bottom: 1rem; color: #94a3b8; }
        .upload-area.has-file .icon-large { color: var(--success); }

        /* Results Section */
        .results-container {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: 0.75rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            overflow: hidden;
            display: none;
        }
        .results-container.active { display: block; }

        .toolbar {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            background: #f8fafc;
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            justify-content: space-between;
            align-items: center;
        }

        .stats { display: flex; gap: 0.5rem; font-size: 0.875rem; }
        .stat-item { padding: 0.35rem 0.75rem; border-radius: 0.375rem; border: 1px solid var(--border); background: white; font-weight: 600; }
        .stat-found { border-color: #bbf7d0; background: #f0fdf4; color: #15803d; }
        .stat-missing { border-color: #fecaca; background: #fef2f2; color: #b91c1c; }

        .controls { display: flex; gap: 0.75rem; }
        select, button {
            padding: 0.5rem 1rem;
            border-radius: 0.375rem;
            border: 1px solid var(--border);
            font-size: 0.875rem;
            cursor: pointer;
            background: white;
        }
        button.btn-primary { background: #1e293b; color: white; border: none; }

        /* Table */
        .table-wrapper { overflow-x: auto; max-height: 600px; }
        table { width: 100%; border-collapse: collapse; font-size: 0.9rem; }
        th {
            background: #f8fafc;
            text-align: left;
            padding: 1rem 1.5rem;
            font-weight: 600;
            color: var(--text-muted);
            border-bottom: 1px solid var(--border);
            position: sticky;
            top: 0;
            z-index: 10;
        }
        td { padding: 0.85rem 1.5rem; border-bottom: 1px solid #f1f5f9; vertical-align: top; }
        tr:hover { background-color: #f8fafc; }

        /* Status Tags */
        .status-tag {
            display: inline-flex;
            align-items: center;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 700;
        }
        .status-found { background: var(--success-bg); color: var(--success); }
        .status-missing { background: #f1f5f9; color: var(--text-muted); }
        
        /* Context/Transformation Info */
        .transformation-info {
            display: flex;
            align-items: center;
            gap: 6px;
            margin-top: 4px;
            font-size: 0.8rem;
            color: #64748b;
        }
        .arrow-icon { color: #94a3b8; font-family: monospace; }
        .base-word { font-weight: 700; color: #2563eb; }
        .context-badge {
            font-size: 0.7rem;
            padding: 1px 6px;
            border-radius: 4px;
            border: 1px solid;
            white-space: nowrap;
        }
        
        /* Context Colors */
        .ctx-irregular { color: #7e22ce; background: #f3e8ff; border-color: #d8b4fe; }
        .ctx-plural { color: #d97706; background: #fffbeb; border-color: #fcd34d; }
        .ctx-tense { color: #059669; background: #ecfdf5; border-color: #6ee7b7; }
        .ctx-variant { color: #0284c7; background: #e0f2fe; border-color: #7dd3fc; }

        /* Level Badges */
        .level-group { display: flex; flex-wrap: wrap; gap: 0.5rem; }
        .level-badge {
            display: flex;
            align-items: center;
            border-radius: 0.375rem;
            font-size: 0.75rem;
            font-weight: 600;
            padding: 0.25rem 0.5rem;
            border: 1px solid transparent;
        }
        .lvl-A { background: var(--level-a-bg); color: var(--level-a-text); border-color: #bfdbfe; }
        .lvl-B { background: var(--level-b-bg); color: var(--level-b-text); border-color: #fde047; }
        .lvl-C { background: var(--level-c-bg); color: var(--level-c-text); border-color: #e9d5ff; }

        .error-msg {
            color: #dc2626;
            background: #fee2e2;
            padding: 0.75rem;
            border-radius: 0.5rem;
            margin-top: 1rem;
            font-size: 0.875rem;
            display: none;
        }
    </style>
</head>
<body>

<div class="container">
    <header>
        <h1>
            Oxford Smart Checker <span class="smart-badge">Context Aware</span>
        </h1>
        <p style="color: var(--text-muted);">
            Supports: <strong>Irregular Verbs, UK/US Swaps, Plurals & Tenses</strong>
        </p>
    </header>

    <div class="grid">
        <!-- Text Input -->
        <div class="card">
            <div class="card-header">
                <div class="card-label">1. Input Word List</div>
            </div>
            <textarea id="inputText" placeholder="Paste your words here...&#10;Examples:&#10;goes (3rd Person -> finds go)&#10;apples (Plural -> finds apple)&#10;went (Irregular -> finds go)&#10;coloured (UK Past -> find color)"></textarea>
        </div>

        <!-- CSV Upload -->
        <div class="card">
            <div class="card-header">
                <div class="card-label">2. Upload Oxford CSV</div>
                <span id="fileStatus" style="font-size: 0.8rem; color: #6b7280;">No file selected</span>
            </div>
            
            <div class="upload-area" id="dropZone">
                <input type="file" id="fileInput" accept=".csv" style="display: none;">
                <div id="uploadPlaceholder">
                    <svg class="icon-large" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg>
                    <p style="font-weight: bold; color: #374151;">Click to Upload CSV</p>
                </div>
                <div id="fileInfo" style="display: none;">
                    <p id="fileNameDisplay" style="font-weight: bold; color: #1f2937;"></p>
                </div>
            </div>
            <div id="errorMsg" class="error-msg"></div>
        </div>
    </div>

    <!-- Results -->
    <div id="resultsContainer" class="results-container">
        <div class="toolbar">
            <div class="stats">
                <div class="stat-item">Total: <span id="statTotal">0</span></div>
                <div class="stat-item stat-found">Found: <span id="statFound">0</span></div>
                <div class="stat-item stat-missing">Missing: <span id="statMissing">0</span></div>
            </div>
            <div class="controls">
                <select id="filterSelect">
                    <option value="ALL">Show All</option>
                    <option value="FOUND">Only Found</option>
                    <option value="NOT_FOUND">Only Not Found</option>
                </select>
                <button id="btnExport" class="btn-primary">Export CSV</button>
            </div>
        </div>
        <div class="table-wrapper">
            <table id="resultTable">
                <thead>
                    <tr>
                        <th style="width: 35%;">Input Word & Context</th>
                        <th style="width: 15%;">Status</th>
                        <th style="width: 50%;">Oxford Details</th>
                    </tr>
                </thead>
                <tbody id="tableBody"></tbody>
            </table>
        </div>
    </div>
</div>

<script>
    let csvDataMap = new Map();
    let analysisResults = [];
    let currentFilter = 'ALL';

    const inputText = document.getElementById('inputText');
    const fileInput = document.getElementById('fileInput');
    const dropZone = document.getElementById('dropZone');
    const uploadPlaceholder = document.getElementById('uploadPlaceholder');
    const fileInfo = document.getElementById('fileInfo');
    const fileNameDisplay = document.getElementById('fileNameDisplay');
    const fileStatus = document.getElementById('fileStatus');
    const errorMsg = document.getElementById('errorMsg');
    const resultsContainer = document.getElementById('resultsContainer');
    const tableBody = document.getElementById('tableBody');
    const statTotal = document.getElementById('statTotal');
    const statFound = document.getElementById('statFound');
    const statMissing = document.getElementById('statMissing');
    const filterSelect = document.getElementById('filterSelect');
    const btnExport = document.getElementById('btnExport');

    // --- IRREGULAR VERBS ---
    const irregularVerbs = {
        "arose": "arise", "arisen": "arise", "awoke": "awake", "awoken": "awake",
        "bore": "bear", "born": "bear", "borne": "bear", "beat": "beat", "beaten": "beat",
        "became": "become", "become": "become", "began": "begin", "begun": "begin",
        "bent": "bend", "bet": "bet", "bound": "bind", "bit": "bite", "bitten": "bite",
        "bled": "bleed", "blew": "blow", "blown": "blow", "broke": "break", "broken": "break",
        "bred": "breed", "brought": "bring", "built": "build", "burned": "burn", "burnt": "burn",
        "burst": "burst", "bought": "buy", "caught": "catch", "chose": "choose", "chosen": "choose",
        "clung": "cling", "came": "come", "come": "come", "cost": "cost", "crept": "creep",
        "cut": "cut", "dealt": "deal", "dug": "dig", "did": "do", "done": "do",
        "drew": "draw", "drawn": "draw", "dreamed": "dream", "dreamt": "dream",
        "drank": "drink", "drunk": "drink", "drove": "drive", "driven": "drive",
        "ate": "eat", "eaten": "eat", "fell": "fall", "fallen": "fall", "fed": "feed",
        "felt": "feel", "fought": "fight", "found": "find", "fled": "flee",
        "flew": "fly", "flown": "fly", "forbade": "forbid", "forbidden": "forbid",
        "forgot": "forget", "forgotten": "forget", "forgave": "forgive", "forgiven": "forgive",
        "froze": "freeze", "frozen": "freeze", "got": "get", "gotten": "get",
        "gave": "give", "given": "give", "went": "go", "gone": "go", "goes": "go", // Added goes for safety in irregular map too
        "ground": "grind", "grew": "grow", "grown": "grow", "hung": "hang",
        "had": "have", "has": "have", "heard": "hear", "hid": "hide", "hidden": "hide",
        "hit": "hit", "held": "hold", "hurt": "hurt", "kept": "keep", "knelt": "kneel",
        "knew": "know", "known": "know", "laid": "lay", "led": "lead",
        "leapt": "leap", "leaped": "leap", "learned": "learn", "learnt": "learn",
        "left": "leave", "lent": "lend", "let": "let", "lay": "lie", "lain": "lie",
        "lit": "light", "lighted": "light", "lost": "lose", "made": "make",
        "meant": "mean", "met": "meet", "mistook": "mistake", "mistaken": "mistake",
        "paid": "pay", "put": "put", "read": "read", "rode": "ride", "ridden": "ride",
        "rang": "ring", "rung": "ring", "rose": "rise", "risen": "rise", "ran": "run", "run": "run",
        "said": "say", "saw": "see", "seen": "see", "sought": "seek", "sold": "sell",
        "sent": "send", "set": "set", "sewed": "sew", "sewn": "sew",
        "shook": "shake", "shaken": "shake", "shone": "shine", "shot": "shoot",
        "showed": "show", "shown": "show", "shrank": "shrink", "shrunk": "shrink",
        "shut": "shut", "sang": "sing", "sung": "sing", "sank": "sink", "sunk": "sink",
        "sat": "sit", "slept": "sleep", "slid": "slide", "smelled": "smell", "smelt": "smell",
        "spoke": "speak", "spoken": "speak", "sped": "speed", "spelled": "spell", "spelt": "spell",
        "spent": "spend", "spilled": "spill", "spilt": "spill", "spun": "spin",
        "spat": "spit", "split": "split", "spoiled": "spoil", "spoilt": "spoil",
        "spread": "spread", "sprang": "spring", "sprung": "spring", "stood": "stand",
        "stole": "steal", "stolen": "steal", "stuck": "stick", "stung": "sting",
        "stank": "stink", "stunk": "stink", "struck": "strike", "swore": "swear", "sworn": "swear",
        "swept": "sweep", "swam": "swim", "swum": "swim", "swung": "swing",
        "took": "take", "taken": "take", "taught": "teach", "tore": "tear", "torn": "tear",
        "told": "tell", "thought": "think", "threw": "throw", "thrown": "throw",
        "understood": "understand", "upset": "upset", "woke": "wake", "woken": "wake",
        "wore": "wear", "worn": "wear", "wept": "weep", "won": "win", "wound": "wind",
        "withdrew": "withdraw", "withdrawn": "withdraw", "wrote": "write", "written": "write"
    };

    // --- HELPER: Is this class a verb? ---
    function isVerbClass(cls) {
        if (!cls) return true; // Keep empty classes just in case
        const c = cls.toLowerCase();
        return c.includes('verb') || c === 'v' || c === 'v.' || c === '?';
    }

    // --- ALGORITHM ---
    function getSpellingVariants(word) {
        const variants = new Set();
        const w = word.toLowerCase();
        const trySwap = (regex, replacement) => { if (regex.test(w)) variants.add(w.replace(regex, replacement)); };
        trySwap(/our$/, 'or'); trySwap(/or$/, 'our');
        trySwap(/ise$/, 'ize'); trySwap(/ize$/, 'ise');
        trySwap(/yse$/, 'yze'); trySwap(/yze$/, 'yse');
        trySwap(/re$/, 'er'); trySwap(/er$/, 're');
        if (w.includes('ll')) variants.add(w.replace('ll', 'l'));
        return Array.from(variants);
    }

    function getStemmedForms(word) {
        const forms = new Set();
        const w = word.toLowerCase();
        if (w.length < 3) return [];
        if (w.endsWith('ies')) forms.add(w.slice(0, -3) + 'y');
        if (w.endsWith('es')) forms.add(w.slice(0, -2));
        if (w.endsWith('s') && !w.endsWith('ss')) forms.add(w.slice(0, -1));
        if (w.endsWith('ied')) forms.add(w.slice(0, -3) + 'y');
        if (w.endsWith('ed')) {
            forms.add(w.slice(0, -1)); forms.add(w.slice(0, -2));
            const base = w.slice(0, -2);
            if (base.length > 2 && base[base.length-1] === base[base.length-2]) forms.add(base.slice(0, -1));
        }
        if (w.endsWith('ing')) {
            forms.add(w.slice(0, -3)); forms.add(w.slice(0, -3) + 'e');
            const base = w.slice(0, -3);
            if (base.length > 2 && base[base.length-1] === base[base.length-2]) forms.add(base.slice(0, -1));
        }
        return Array.from(forms);
    }

    function findMatch(inputWord) {
        const lowerInput = inputWord.toLowerCase();

        // 1. Exact Match (Show everything)
        if (csvDataMap.has(lowerInput)) {
            return { found: true, type: 'exact', matchWord: lowerInput, data: csvDataMap.get(lowerInput) };
        }

        // 2. Irregular Verbs (FILTER FOR VERBS)
        if (irregularVerbs[lowerInput]) {
            const baseForm = irregularVerbs[lowerInput];
            if (csvDataMap.has(baseForm)) {
                const allMatches = csvDataMap.get(baseForm);
                const verbMatches = allMatches.filter(m => isVerbClass(m.class));
                const finalMatches = verbMatches.length > 0 ? verbMatches : allMatches;
                return { found: true, type: 'irregular', matchWord: baseForm, data: finalMatches };
            }
        }

        // 3. Spelling Variants
        const variants = getSpellingVariants(lowerInput);
        for (const v of variants) {
            if (csvDataMap.has(v)) return { found: true, type: 'variant', matchWord: v, data: csvDataMap.get(v) };
        }

        // 4. Stemming
        const stems = getStemmedForms(lowerInput);
        for (const s of stems) {
            if (csvDataMap.has(s)) return { found: true, type: 'lemma', matchWord: s, data: csvDataMap.get(s) };
            const stemVariants = getSpellingVariants(s);
            for (const sv of stemVariants) {
                if (csvDataMap.has(sv)) return { found: true, type: 'variant_lemma', matchWord: sv, data: csvDataMap.get(sv) };
            }
        }

        return { found: false, type: null, matchWord: null, data: [] };
    }

    // --- EVENT LISTENERS ---
    dropZone.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => { if (e.target.files[0]) handleFileUpload(e.target.files[0]); });
    inputText.addEventListener('input', runAnalysis);
    filterSelect.addEventListener('change', (e) => { currentFilter = e.target.value; renderTable(); });
    btnExport.addEventListener('click', exportCSV);

    function handleFileUpload(file) {
        const reader = new FileReader();
        errorMsg.style.display = 'none';
        reader.onload = (e) => {
            try {
                processCSV(e.target.result);
                fileNameDisplay.textContent = file.name;
                uploadPlaceholder.style.display = 'none';
                fileInfo.style.display = 'block';
                dropZone.classList.add('has-file');
                fileStatus.textContent = `Loaded ${csvDataMap.size} words`;
                fileStatus.style.color = 'var(--success)';
                if (inputText.value.trim()) runAnalysis();
            } catch (err) {
                errorMsg.textContent = "CSV Error: " + err.message;
                errorMsg.style.display = 'block';
                csvDataMap.clear();
            }
        };
        reader.readAsText(file);
    }

    function processCSV(text) {
        const lines = text.split(/\r?\n/);
        const newMap = new Map();
        let count = 0;
        lines.forEach(line => {
            if (!line.trim()) return;
            const parts = line.split(',');
            if (parts.length < 2) return;
            const rawWord = parts[0].trim();
            if (!rawWord || (rawWord.toLowerCase() === 'word' && parts[1].includes('class'))) return;
            
            let rawClass = parts.length >= 3 ? parts[1].trim() : '?';
            let rawLevel = parts.length >= 3 ? parts[2].trim() : parts[1].trim();

            const key = rawWord.toLowerCase();
            const entry = { original: rawWord, class: rawClass, level: rawLevel.toUpperCase() };
            
            if (newMap.has(key)) newMap.get(key).push(entry);
            else newMap.set(key, [entry]);
            count++;
        });
        if (count === 0) throw new Error("No valid data found");
        csvDataMap = newMap;
    }

    function runAnalysis() {
        const words = inputText.value.split(/[\n,;\t]+/).map(w => w.trim()).filter(w => w.length > 0);
        if (words.length === 0) { resultsContainer.classList.remove('active'); return; }
        
        analysisResults = [...new Set(words)].map(inputWord => {
            const result = findMatch(inputWord);
            return { input: inputWord, ...result, matches: result.data };
        });

        resultsContainer.classList.add('active');
        renderTable();
    }

    function renderTable() {
        let displayData = analysisResults;
        if (currentFilter === 'FOUND') displayData = analysisResults.filter(r => r.found);
        else if (currentFilter === 'NOT_FOUND') displayData = analysisResults.filter(r => !r.found);

        statTotal.textContent = analysisResults.length;
        statFound.textContent = analysisResults.filter(r => r.found).length;
        statMissing.textContent = analysisResults.length - statFound.textContent;

        tableBody.innerHTML = '';
        if (displayData.length === 0) {
            tableBody.innerHTML = `<tr><td colspan="3" style="text-align:center; padding: 3rem; color: #9ca3af;">No results</td></tr>`;
            return;
        }

        displayData.forEach(item => {
            const tr = document.createElement('tr');
            
            // --- 1. Word & Context Column ---
            const tdWord = document.createElement('td');
            const wordDiv = document.createElement('div');
            wordDiv.style.fontWeight = '500';
            wordDiv.style.fontSize = '1rem';
            wordDiv.textContent = item.input;
            tdWord.appendChild(wordDiv);

            // Logic for Transformation Display
            if (item.found && item.type !== 'exact') {
                const infoDiv = document.createElement('div');
                infoDiv.className = 'transformation-info';

                let labelText = "";
                let labelClass = "context-badge ";

                if (item.type === 'irregular') {
                    labelText = "Irregular: Past Tense & Participle";
                    labelClass += "ctx-irregular";
                } else if (item.type === 'variant' || item.type === 'variant_lemma') {
                    labelText = "US/UK Swap";
                    labelClass += "ctx-variant";
                } else if (item.type === 'lemma') {
                    // Infer context based on suffix AND destination class
                    const inp = item.input.toLowerCase();
                    
                    // Check if the matched base word is a Verb
                    const isDestVerb = item.matches.some(m => 
                        m.class && (m.class.toLowerCase().includes('verb') || m.class.toLowerCase() === 'v')
                    );

                    if (inp.endsWith('ing') || inp.endsWith('ed')) {
                        labelText = "Tense -> Base Form";
                        labelClass += "ctx-tense";
                    } else if (inp.endsWith('s') || inp.endsWith('es') || inp.endsWith('ies')) {
                        if (isDestVerb) {
                            // It ends in 's' but matches a verb (e.g. goes -> go)
                            labelText = "3rd Person -> Base Form";
                            labelClass += "ctx-tense";
                        } else {
                            // It ends in 's' and matches a noun (e.g. apples -> apple)
                            labelText = "Plurals -> Singular";
                            labelClass += "ctx-plural";
                        }
                    } else {
                        labelText = "Form -> Base";
                        labelClass += "ctx-plural"; // Fallback color
                    }
                }

                infoDiv.innerHTML = `
                    <span class="arrow-icon">↳</span>
                    <span class="base-word">${item.matchWord}</span>
                    <span class="${labelClass}">${labelText}</span>
                `;
                tdWord.appendChild(infoDiv);
            }
            
            // --- 2. Status Column ---
            const tdStatus = document.createElement('td');
            const statusSpan = document.createElement('span');
            statusSpan.className = `status-tag ${item.found ? 'status-found' : 'status-missing'}`;
            statusSpan.textContent = item.found ? 'Found' : 'Not Found';
            tdStatus.appendChild(statusSpan);

            // --- 3. Details Column ---
            const tdDetails = document.createElement('td');
            if (item.found) {
                const group = document.createElement('div');
                group.className = 'level-group';
                item.matches.forEach(m => {
                    const badge = document.createElement('div');
                    let colorClass = '';
                    if (m.level.startsWith('A')) colorClass = 'lvl-A';
                    else if (m.level.startsWith('B')) colorClass = 'lvl-B';
                    else if (m.level.startsWith('C')) colorClass = 'lvl-C';
                    badge.className = `level-badge ${colorClass}`;
                    badge.textContent = `${m.level} • ${m.class}`;
                    group.appendChild(badge);
                });
                tdDetails.appendChild(group);
            } else {
                tdDetails.textContent = '-';
                tdDetails.style.color = '#d1d5db';
            }

            tr.appendChild(tdWord); tr.appendChild(tdStatus); tr.appendChild(tdDetails);
            tableBody.appendChild(tr);
        });
    }

    function exportCSV() {
        if (analysisResults.length === 0) return;
        const header = "Input Word,Found,Converted Word,Context,Details\n";
        const rows = analysisResults.map(r => {
            const details = r.matches.map(m => `[${m.level}] ${m.class}`).join('; ');
            let context = "Exact Match";
            if (r.type === 'irregular') context = "Irregular: Past Tense & Participle";
            else if (r.type === 'variant') context = "US/UK Swap";
            else if (r.type === 'lemma') {
                const inp = r.input.toLowerCase();
                const isDestVerb = r.matches.some(m => m.class && (m.class.toLowerCase().includes('verb') || m.class.toLowerCase() === 'v'));
                
                if (inp.endsWith('ing') || inp.endsWith('ed')) context = "Tense -> Base Form";
                else if (inp.endsWith('s') || inp.endsWith('es') || inp.endsWith('ies')) {
                    if (isDestVerb) context = "3rd Person -> Base Form";
                    else context = "Plurals -> Singular";
                }
                else context = "Form -> Base";
            }
            
            const converted = (r.found && r.type !== 'exact') ? r.matchWord : r.input;
            
            return `${r.input},${r.found ? 'Yes' : 'No'},${converted},${context},"${details.replace(/"/g, '""')}"`;
        }).join("\n");
        const link = document.createElement('a');
        link.href = URL.createObjectURL(new Blob([header + rows], { type: 'text/csv;charset=utf-8;' }));
        link.download = 'oxford_check_results.csv';
        document.body.appendChild(link); link.click(); document.body.removeChild(link);
    }
</script>

</body>
</html>
