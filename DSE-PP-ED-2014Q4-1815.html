<!DOCTYPE html>
<html lang="zh-Hant">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>2024 DSE ICT 試卷互動解答 (最終修正版)</title>
    <style>
        :root {
            --primary-color: #005a9c;
            --secondary-color: #f0f8ff;
            --accent-color: #ffc107;
            --text-color: #333;
            --border-color: #ccc;
            --bg-color: #fff;
            --code-bg: #f5f5f5;
            --success-color: #28a745;
            --z-color: #e67e22;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: #f4f7f9;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 900px;
            margin: auto;
            background: var(--bg-color);
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        h1, h2, h3 {
            color: var(--primary-color);
            border-bottom: 2px solid var(--secondary-color);
            padding-bottom: 10px;
        }
        h1 {
            text-align: center;
        }
        .apology-box {
            background-color: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
            padding: 15px;
            margin-bottom: 20px;
            border-radius: 5px;
        }
        section {
            background: var(--secondary-color);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 25px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }
        .button-group {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 10px;
        }
        button {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 10px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
            margin-top: 10px;
        }
        button:hover {
            background-color: #004170;
        }
        button:disabled {
            background-color: #aaa;
            cursor: not-allowed;
        }
        .grid-container {
            display: grid;
            grid-template-columns: repeat(3, 60px);
            grid-template-rows: repeat(3, 60px);
            gap: 5px;
            justify-content: center;
            margin: 20px 0 5px 0;
        }
        .grid-cell {
            width: 60px;
            height: 60px;
            display: flex;
            justify-content: center;
            align-items: center;
            border: 2px solid var(--border-color);
            font-size: 24px;
            font-weight: bold;
            background-color: white;
            transition: all 0.3s ease;
        }
        .grid-cell.z-char {
            background-color: var(--z-color);
            color: white;
            border-color: var(--z-color);
        }
        .command-text {
            text-align: center;
            font-weight: bold;
            min-height: 24px;
            color: var(--primary-color);
        }
        pre {
            background: var(--code-bg);
            padding: 15px;
            border-radius: 5px;
            border: 1px solid #ddd;
            white-space: pre-wrap;
            word-wrap: break-word;
            font-size: 15px;
        }
        code {
            font-family: "Courier New", Courier, monospace;
        }
        .answer-box {
            display: inline-block;
            background: var(--accent-color);
            color: var(--text-color);
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: bold;
            opacity: 0;
            transition: opacity 0.5s ease;
        }
        .answer-box.visible {
            opacity: 1;
        }
        .explanation {
            margin-top: 15px;
            padding: 15px;
            background: #e9f5ff;
            border-left: 4px solid var(--primary-color);
        }
        .stack-container {
            display: flex;
            flex-direction: column-reverse;
            width: 80px;
            margin: 10px auto;
            border: 2px solid var(--primary-color);
            border-top: none;
            padding-top: 10px;
            position: relative;
        }
        .stack-label {
            position: absolute;
            top: -25px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-color);
            padding: 0 5px;
            font-weight: bold;
        }
        .stack-item {
            background-color: var(--accent-color);
            border-top: 2px solid var(--primary-color);
            text-align: center;
            padding: 10px;
            font-size: 18px;
            font-weight: bold;
            transition: all 0.5s ease;
        }
        .stack-item.popped {
            transform: translateY(-50px) scale(0.5);
            opacity: 0;
        }
        .final-result {
            margin-top: 20px;
            padding: 15px;
            background-color: #e8f5e9;
            border: 1px solid var(--success-color);
            border-radius: 5px;
        }
        .final-result h3 {
            color: var(--success-color);
            border: none;
            margin-top: 0;
        }
        .flex-center {
            display: flex;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>2024 DSE ICT 試卷互動解答 (最終修正版)</h1>

        <div class="apology-box">
            <strong>更正說明：</strong> 再次感謝您的指正！已根據您提供的圖片，確認本題定義為 <strong>x=行, y=列</strong>，並修正了 <strong>(c)(i) 和 (c)(iii) 中 History 堆疊的正確內容</strong>。以下所有內容均已根據此最終規則全面修正。
        </div>

        <!-- Part (a) -->
        <section>
            <h2>(a) 執行 swapBD 指令序列</h2>
            <p>題目要求按順序執行 <code>swapBD(1)</code>、<code>swapBD(0)</code> 和 <code>swapBD(1)</code>。請使用下方按鈕逐步查看變更。</p>
            
            <div class="flex-center" style="flex-direction: column;">
                <div id="grid-a-interactive"></div>
                <p id="command-a-text" class="command-text"></p>
            </div>

            <div class="button-group">
                <button id="btn-a-prev">上一步</button>
                <button id="btn-a-next">下一步</button>
            </div>

            <div class="explanation">
                <strong>解說 (已更正)：</strong>
                <p>根據題目定義，x=行, y=列。初始狀態 'z' 在 <code>BD[2,1]</code>。</p>
                <ol>
                    <li><strong>初始狀態：</strong> 'z' 在 `x=2, y=1` (第2行, 第1列)。</li>
                    <li><code>swapBD(1)</code> (右)：'z' 與右邊的 'f' 交換。'z' 移至 `x=2, y=2`。</li>
                    <li><code>swapBD(0)</code> (上)：'z' 與上方的 'e' 交換。'z' 移至 `x=1, y=2`。</li>
                    <li><code>swapBD(1)</code> (右)：'z' 與右邊的 'a' 交換。'z' 移至 `x=1, y=3`。</li>
                </ol>
                <div class="final-result">
                    <h3>最終內容</h3>
                    <div class="flex-center">
                        <div id="grid-a-final"></div>
                    </div>
                </div>
            </div>
        </section>

        <!-- Part (b) -->
        <section>
            <h2>(b) 完成 swapBD 的偽代碼</h2>
            <p>根據交換邏輯 (x=行, y=列)，填充偽代碼中的空白部分。</p>
            <pre><code>如果 dir = 0 則
    如果 x = 1 則 輸出 '上：互換不成功'
    否則
        BD[x,y] ← <span id="ans-b1" class="answer-box">BD[x-1, y]</span>
        BD[x-1,y] ← 'z'
        x ← x - 1
如果 dir = 1 則
    如果 y = 3 則 輸出 '右：互換不成功'
    否則
        BD[x,y] ← <span id="ans-b2" class="answer-box">BD[x, y+1]</span>
        BD[x,y+1] ← 'z'
        y ← y + 1</code></pre>
            <div style="text-align:center;">
                <button onclick="revealAnswers(['ans-b1', 'ans-b2'])">顯示答案</button>
            </div>
            <div class="explanation">
                <strong>解說 (已更正)：</strong>
                <ul>
                    <li><strong>dir = 0 (上移):</strong> 向上移動是減少**行數 `x`**。'z' 要和其上方 <code>BD[x-1, y]</code> 的元素交換。所以，'z' 目前的位置 <code>BD[x,y]</code> 應被上方元素的值覆蓋，即 <code>BD[x,y] ← BD[x-1, y]</code>。</li>
                    <li><strong>dir = 1 (右移):</strong> 向右移動是增加**列數 `y`**。'z' 要和其右方 <code>BD[x, y+1]</code> 的元素交換。所以，'z' 目前的位置 <code>BD[x,y]</code> 應被右方元素的值覆蓋，即 <code>BD[x,y] ← BD[x, y+1]</code>。</li>
                </ul>
            </div>
        </section>

        <!-- Part (c) -->
        <section>
            <h2>(c) 重置棋盤 (resetBD) 和簡化歷史 (SimplifyH)</h2>

            <h3>(i) 假設 History 的內容，寫出 resetBD 將會執行的序列</h3>
            <p><code>History</code> 堆疊從頂端到底端為 <code>[3, 0, 1]</code>。<code>resetBD</code> 會彈出這些值並執行反向操作。</p>
            <div class="flex-center" style="flex-direction: column;">
                <div class="stack-container" id="stack-c1">
                    <div class="stack-label">History (頂端)</div>
                    <div class="stack-item" id="c1-item-1">1</div>
                    <div class="stack-item" id="c1-item-0">0</div>
                    <div class="stack-item" id="c1-item-3">3</div>
                </div>
                <p id="command-c1-text" class="command-text"></p>
            </div>
            <div class="button-group">
                <button id="btn-c1-prev">上一步</button>
                <button id="btn-c1-next">下一步</button>
            </div>
            <div class="explanation">
                <strong>解說 (已更正)：</strong>
                <p><code>resetBD</code> 的目的是撤銷操作。反向操作的規則為：上(0)↔下(2), 右(1)↔左(3)。</p>
                <p>操作序列如下：</p>
                <ol>
                    <li>從 History 彈出 <strong>3</strong> (左)。執行相反操作：<code>swapBD(1)</code> (右)。</li>
                    <li>從 History 彈出 <strong>0</strong> (上)。執行相反操作：<code>swapBD(2)</code> (下)。</li>
                    <li>從 History 彈出 <strong>1</strong> (右)。執行相反操作：<code>swapBD(3)</code> (左)。</li>
                </ol>
                <div class="final-result">
                    <h3>執行序列</h3>
                    <code>swapBD( <span class="answer-box visible">1</span> )</code>, <code>swapBD( <span class="answer-box visible">2</span> )</code>, <code>swapBD( <span class="answer-box visible">3</span> )</code>
                </div>
            </div>

            <h3>(ii) 完成 resetBD 的偽代碼</h3>
            <pre><code>resetBD
    當 History 不是空的 執行
        topH ← pop(History)
        swapBD( <span id="ans-c2" class="answer-box">(topH + 2) MOD 4</span> )</code></pre>
            <div style="text-align:center;">
                <button onclick="revealAnswers(['ans-c2'])">顯示答案</button>
            </div>
            <div class="explanation">
                <strong>解說：</strong>
                <p>反向操作的 `dir` 值與原操作的 `dir` 值 `topH` 存在一個固定的數學關係，即相差2。使用模數運算 <code>(topH + 2) MOD 4</code> 可以優雅地處理這個循環關係 (0↔2, 1↔3)。這個邏輯與 `x`, `y` 的具體定義無關。</p>
            </div>

            <h3>(iii) BD 和 History 的最終內容，以及單個重置交換</h3>
            <p>給定 BD 的最終內容和 History 的內容，執行 <code>resetBD</code>。</p>
            
            <div class="flex-center">
                <div style="text-align:center;">
                    <p style="font-weight:bold;">BD 變化</p>
                    <div id="grid-c3-start"></div>
                    <p id="status-c3" class="command-text"></p>
                </div>
                <div style="margin: 0 20px; text-align:center;">
                    <p style="font-weight:bold;">History 變化</p>
                    <div class="stack-container" id="stack-c3">
                        <div class="stack-label">頂端</div>
                        <div class="stack-item" id="c3-item-3c">3</div>
                        <div class="stack-item" id="c3-item-1c">1</div>
                        <div class="stack-item" id="c3-item-3b">3</div>
                        <div class="stack-item" id="c3-item-1b">1</div>
                        <div class="stack-item" id="c3-item-3a">3</div>
                        <div class="stack-item" id="c3-item-1a">1</div>
                        <div class="stack-item" id="c3-item-2">2</div>
                    </div>
                </div>
            </div>
            <div class="button-group">
                <button id="btn-c3-prev">上一步</button>
                <button id="btn-c3-next">下一步</button>
            </div>
            <div class="explanation">
                <strong>解說 (已更正)：</strong>
                <p>使用按鈕逐步觀察 `resetBD` 的過程。`History` 中的 `[2, 1, 3, 1, 3, 1, 3]` (從頂端到底) 被逐一彈出並執行反向操作。執行的序列為 <code>swapBD(0)</code>, <code>swapBD(3)</code>, <code>swapBD(1)</code>, <code>swapBD(3)</code>, <code>swapBD(1)</code>, <code>swapBD(3)</code>, <code>swapBD(1)</code>。</p>
                <ul>
                    <li>`swapBD(3)` (左) 和 `swapBD(1)` (右) 是相反操作。在執行序列中，從第二步開始，連續的 `(3,1)` 操作對會互相抵消。</li>
                    <li>淨效果只剩下第一個操作 `swapBD(0)` (上)。'z' 從初始的 `x=3, y=2` 移動到最終的 `x=2, y=2`。</li>
                </ul>
                <div class="final-result">
                    <h3>最終內容</h3>
                    <p>執行後，BD 的內容如下圖所示，而 <strong>History 堆疊變為空</strong>。</p>
                    <div class="flex-center">
                         <div id="grid-c3-final"></div>
                    </div>
                    <h3>單個重置交換</h3>
                    <p>在執行 `resetBD` 之前，'z' 位於 <code>x=3, y=2</code>。要將其重置到題目的「初始內容」（即執行 `History` 序列之前的狀態），需要撤銷 `History` 的淨效果。簡化 `History` `[3, 1, 3, 1, 3, 1, 2]` (從底部讀起) 後，三對 `(3,1)` 互相抵消，只剩下 `[2]`。這表示當前的棋盤狀態是由「初始內容」執行 `swapBD(2)` (下) 得到的。因此，要回到「初始內容」，只需執行相反的 `swapBD(0)` (上) 即可。所以單個重置交換是：<code>swapBD( <span class="answer-box visible">0</span> )</code>。</p>
                </div>
            </div>

            <h3>(iv) 完成 SimplifyH 的偽代碼</h3>
            <pre><code>SimplifyH
    當 History 不是空的 執行
        如果 TmpStack 是空的 則
            push(TmpStack, <span id="ans-c4-1" class="answer-box">pop(History)</span>)
        否則
            topH ← pop(History)
            topT ← pop(TmpStack)
            如果 (topH 和 topT 的差) ≠ <span id="ans-c4-2" class="answer-box">2</span> 則
                push(TmpStack, <span id="ans-c4-3" class="answer-box">topT</span>)
                push(TmpStack, <span id="ans-c4-4" class="answer-box">topH</span>)
    當 TmpStack 不是空的 執行
        push(History, pop(TmpStack))</code></pre>
            <div style="text-align:center;">
                <button onclick="revealAnswers(['ans-c4-1', 'ans-c4-2', 'ans-c4-3', 'ans-c4-4'])">顯示答案</button>
            </div>
            <div class="explanation">
                <strong>解說：</strong>
                <p><code>SimplifyH</code> 的目標是移除 `History` 中可以互相抵消的連續操作。一對可以抵消的操作是方向相反的操作（如上/下，左/右）。它們的 `dir` 值相差為 2。這個演算法的邏輯與 `x`, `y` 的具體定義無關，因此答案不變。</p>
            </div>
        </section>

    </div>

    <script>
    document.addEventListener('DOMContentLoaded', function() {
        
        function createGrid(containerOrId, gridData) {
            const container = (typeof containerOrId === 'string')
                ? document.getElementById(containerOrId)
                : containerOrId;
            if (!container) return;
            container.innerHTML = '';
            const gridContainer = document.createElement('div');
            gridContainer.className = 'grid-container';
            gridData.forEach(rowData => {
                rowData.forEach(cellValue => {
                    const cell = document.createElement('div');
                    cell.className = 'grid-cell';
                    cell.textContent = cellValue;
                    if (cellValue === 'z') cell.classList.add('z-char');
                    gridContainer.appendChild(cell);
                });
            });
            container.appendChild(gridContainer);
        }

        window.revealAnswers = function(ids) {
            ids.forEach(id => {
                const el = document.getElementById(id);
                if (el) el.classList.add('visible');
            });
        }

        // --- Part (a) Logic ---
        let animationStatesA = [];
        let currentStepA = 0;
        function setupAnimationA() {
            animationStatesA = [];
            let grid = JSON.parse(JSON.stringify([['c', 'e', 'a'], ['z', 'f', 'd'], ['h', 'b', 'g']]));
            let row = 1, col = 0;
            animationStatesA.push({ grid: JSON.parse(JSON.stringify(grid)), command: '初始狀態 (x=2, y=1)' });
            const moves = [{ dir: 1, name: '右' }, { dir: 0, name: '上' }, { dir: 1, name: '右' }];
            moves.forEach((move, index) => {
                let temp;
                if (move.dir === 1) { // Right -> col++
                    temp = grid[row][col]; grid[row][col] = grid[row][col + 1]; grid[row][col + 1] = temp; col++;
                } else if (move.dir === 0) { // Up -> row--
                    temp = grid[row][col]; grid[row][col] = grid[row - 1][col]; grid[row - 1][col] = temp; row--;
                }
                animationStatesA.push({ grid: JSON.parse(JSON.stringify(grid)), command: `步驟 ${index + 1}: 執行 swapBD(${move.dir}) (${move.name})` });
            });
        }
        function updateDisplayA(step) {
            const state = animationStatesA[step];
            createGrid('grid-a-interactive', state.grid);
            document.getElementById('command-a-text').textContent = state.command;
            document.getElementById('btn-a-prev').disabled = (step === 0);
            document.getElementById('btn-a-next').disabled = (step === animationStatesA.length - 1);
        }
        setupAnimationA();
        createGrid('grid-a-final', [['c', 'a', 'z'], ['f', 'e', 'd'], ['h', 'b', 'g']]);
        updateDisplayA(0);
        document.getElementById('btn-a-next').addEventListener('click', () => { if (currentStepA < animationStatesA.length - 1) updateDisplayA(++currentStepA); });
        document.getElementById('btn-a-prev').addEventListener('click', () => { if (currentStepA > 0) updateDisplayA(--currentStepA); });

        // --- Part (c)(i) Logic ---
        let animationStatesC1 = [];
        let currentStepC1 = 0;
        const stackItemsC1 = [document.getElementById('c1-item-3'), document.getElementById('c1-item-0'), document.getElementById('c1-item-1')];
        function setupAnimationC1() {
            animationStatesC1 = [
                { command: '初始狀態' },
                { command: '步驟 1: 彈出 3 (左) → 執行相反操作: swapBD(1) (右)' },
                { command: '步驟 2: 彈出 0 (上) → 執行相反操作: swapBD(2) (下)' },
                { command: '步驟 3: 彈出 1 (右) → 執行相反操作: swapBD(3) (左)' }
            ];
        }
        function updateDisplayC1(step) {
            document.getElementById('command-c1-text').textContent = animationStatesC1[step].command;
            stackItemsC1.forEach((item, index) => {
                item.classList.toggle('popped', index < step);
            });
            document.getElementById('btn-c1-prev').disabled = (step === 0);
            document.getElementById('btn-c1-next').disabled = (step === animationStatesC1.length - 1);
        }
        setupAnimationC1();
        updateDisplayC1(0);
        document.getElementById('btn-c1-next').addEventListener('click', () => { if (currentStepC1 < animationStatesC1.length - 1) updateDisplayC1(++currentStepC1); });
        document.getElementById('btn-c1-prev').addEventListener('click', () => { if (currentStepC1 > 0) updateDisplayC1(--currentStepC1); });

        // --- Part (c)(iii) Logic ---
        let animationStatesC3 = [];
        let currentStepC3 = 0;
        const stackItemIdsC3 = ['c3-item-2', 'c3-item-1a', 'c3-item-3a', 'c3-item-1b', 'c3-item-3b', 'c3-item-1c', 'c3-item-3c'];
        const stackElementsC3 = stackItemIdsC3.map(id => document.getElementById(id));
        
        function setupAnimationC3() {
            animationStatesC3 = [];
            const initialGrid = [['b', 'h', 'a'], ['f', 'd', 'c'], ['e', 'z', 'g']];
            let grid = JSON.parse(JSON.stringify(initialGrid));
            
            // Initial state
            animationStatesC3.push({
                grid: JSON.parse(JSON.stringify(grid)),
                command: '初始狀態 (z 在 x=3, y=2)'
            });

            const poppedValues = [2, 1, 3, 1, 3, 1, 3];
            const dirNames = ['上', '右', '下', '左'];
            let row = 2, col = 1; // 0-based index

            poppedValues.forEach((val, index) => {
                const move = (val + 2) % 4;
                let newRow = row, newCol = col;
                if (move === 0) newRow--; else if (move === 1) newCol++;
                else if (move === 2) newRow++; else if (move === 3) newCol--;
                
                [grid[row][col], grid[newRow][newCol]] = [grid[newRow][newCol], grid[row][col]];
                row = newRow; col = newCol;

                animationStatesC3.push({
                    grid: JSON.parse(JSON.stringify(grid)),
                    command: `步驟 ${index + 1}: 彈出 ${val} (${dirNames[val]})，執行相反操作 swapBD(${move}) (${dirNames[move]})`
                });
            });
        }

        function updateDisplayC3(step) {
            const state = animationStatesC3[step];
            createGrid('grid-c3-start', state.grid);
            document.getElementById('status-c3').textContent = state.command;

            stackElementsC3.forEach((el, index) => {
                el.classList.toggle('popped', index < step);
            });

            document.getElementById('btn-c3-prev').disabled = (step === 0);
            document.getElementById('btn-c3-next').disabled = (step === animationStatesC3.length - 1);
        }

        setupAnimationC3();
        createGrid('grid-c3-final', [['b', 'h', 'a'], ['f', 'z', 'c'], ['e', 'd', 'g']]);
        updateDisplayC3(0);
        document.getElementById('btn-c3-next').addEventListener('click', () => { if (currentStepC3 < animationStatesC3.length - 1) updateDisplayC3(++currentStepC3); });
        document.getElementById('btn-c3-prev').addEventListener('click', () => { if (currentStepC3 > 0) updateDisplayC3(--currentStepC3); });

    });
    </script>

</body>
</html>